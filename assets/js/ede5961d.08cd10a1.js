"use strict";(self.webpackChunkcpp_learn=self.webpackChunkcpp_learn||[]).push([[592],{7349:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var s=t(4848),r=t(8453);const o={},c="Copying and Moving",i={id:"copying",title:"Copying and Moving",description:"When you are writing = you are always copying the value.",source:"@site/docs/19-copying.md",sourceDirName:".",slug:"/copying",permalink:"/learn-cpp/docs/copying",draft:!1,unlisted:!1,editUrl:"https://github.com/michalskibinski109/learn-cpp/tree/main/docs/19-copying.md",tags:[],version:"current",sidebarPosition:19,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"strings",permalink:"/learn-cpp/docs/strings"},next:{title:"RLvalues",permalink:"/learn-cpp/docs/rl-values"}},a={},l=[{value:"Key Points",id:"key-points",level:3}];function d(n){const e={code:"code",h1:"h1",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h1,{id:"copying-and-moving",children:"Copying and Moving"}),"\n",(0,s.jsxs)(e.p,{children:["When you are writing ",(0,s.jsx)(e.code,{children:"="})," you are always copying the value."]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"when copying pointers, you are copying the address, not the value."}),"\n",(0,s.jsx)(e.li,{children:"when copying arrays, you are copying the values, not the address."}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-markdown",children:'\n### Custom Copy Constructor Necessity\n\nA custom copy constructor is crucial for classes that manage dynamic memory. The default copy constructor only performs a **shallow copy**, which can lead to memory leaks and double free errors when objects are copied. A **deep copy**, achieved through a custom copy constructor, ensures each object has its own memory allocation, preventing these issues.\n\n###  Custom String Class Example\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nclass CustomString {\n    char* data;\npublic:\n    CustomString(const char* str = "") {\n        data = new char[std::strlen(str) + 1];\n        std::strcpy(data, str);\n    }\n\n    // Deep copy constructor\n    CustomString(const CustomString& other) {\n        data = new char[std::strlen(other.data) + 1];\n        std::strcpy(data, other.data);\n    }\n\n    ~CustomString() {\n        delete[] data;\n    }\n\n    // Deep copy assignment\n    CustomString& operator=(const CustomString& other) {\n        if (this != &other) {\n            delete[] data;\n            data = new char[std::strlen(other.data) + 1];\n            std::strcpy(data, other.data);\n        }\n        return *this;\n    }\n\n    void print() const {\n        std::cout << data << std::endl;\n    }\n};\n\nint main() {\n    CustomString str1("Hello");\n    CustomString str2 = str1; // Uses deep copy constructor\n\n    str1.print();\n    str2.print();\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"key-points",children:"Key Points"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Custom Copy Constructor"}),": Ensures deep copy to prevent memory leaks and double free errors."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Destructor"}),": Releases allocated memory to avoid leaks."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Copy Assignment Operator"}),": Handles deep copying for object assignments."]}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>c,x:()=>i});var s=t(6540);const r={},o=s.createContext(r);function c(n){const e=s.useContext(o);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function i(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:c(n.components),s.createElement(o.Provider,{value:e},n.children)}}}]);