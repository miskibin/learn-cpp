"use strict";(self.webpackChunkcpp_learn=self.webpackChunkcpp_learn||[]).push([[447],{4231:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var s=t(4848),i=t(8453);const o={},d="STL functions",r={id:"stl-operations",title:"STL functions",description:"enableif and enableif_t",source:"@site/docs/102-stl-operations.md",sourceDirName:".",slug:"/stl-operations",permalink:"/learn-cpp/docs/stl-operations",draft:!1,unlisted:!1,editUrl:"https://github.com/michalskibinski109/learn-cpp/tree/main/docs/102-stl-operations.md",tags:[],version:"current",sidebarPosition:102,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Memory",permalink:"/learn-cpp/docs/memory"},next:{title:"Lambdas",permalink:"/learn-cpp/docs/lambdas"}},a={},c=[{value:"<code>enable_if</code> and <code>enable_if_t</code>",id:"enable_if-and-enable_if_t",level:3},{value:"<code>is_base_of</code> and <code>is_same</code>",id:"is_base_of-and-is_same",level:3},{value:"<code>future</code> and <code>promise</code>",id:"future-and-promise",level:3},{value:"<code>forward</code>",id:"forward",level:3}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"stl-functions",children:"STL functions"}),"\n",(0,s.jsxs)(n.h3,{id:"enable_if-and-enable_if_t",children:[(0,s.jsx)(n.code,{children:"enable_if"})," and ",(0,s.jsx)(n.code,{children:"enable_if_t"})]}),"\n",(0,s.jsxs)(n.p,{children:["The syntax typename ",(0,s.jsx)(n.code,{children:"std::enable_if<condition, return_type>::type"})," is used as the return type of a function template. If the condition is true, it defines the return type; if false, the function is removed from the overload set."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\n#include <type_traits>\n\n// Function template that only accepts integral types\ntemplate<typename T>\ntypename std::enable_if<std::is_integral<T>::value, bool>::type\nis_even(T number) {\n    return number % 2 == 0;\n}\n\n// Function template that only accepts floating-point types\ntemplate<typename T>\ntypename std::enable_if<std::is_floating_point<T>::value, bool>::type\nis_close_to_integer(T number, T epsilon = 0.001) {\n    return std::abs(number - std::round(number)) < epsilon;\n}\n\nint main() {\n    std::cout << "Is 4 even? " << is_even(4) << std::endl;\n    std::cout << "Is 7 even? " << is_even(7) << std::endl;\n    \n    // This would cause a compilation error:\n    // std::cout << "Is 3.14 even? " << is_even(3.14) << std::endl;\n    \n    std::cout << "Is 3.01 close to an integer? " << is_close_to_integer(3.01) << std::endl;\n    std::cout << "Is 3.99 close to an integer? " << is_close_to_integer(3.99) << std::endl;\n    \n    // This would cause a compilation error:\n    // std::cout << "Is 5 close to an integer? " << is_close_to_integer(5) << std::endl;\n    \n    return 0;\n}\n'})}),"\n",(0,s.jsx)(n.admonition,{title:"enable_if_t",type:"note",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"std::enable_if_t"})," is a C++14 feature that simplifies the syntax by defining the return type directly. It is equivalent to ",(0,s.jsx)(n.code,{children:"typename std::enable_if<condition, return_type>::type"}),". For example, ",(0,s.jsx)(n.code,{children:"std::enable_if_t<std::is_integral<T>::value, bool>"})," is equivalent to ",(0,s.jsx)(n.code,{children:"typename std::enable_if<std::is_integral<T>::value, bool>::type"}),"."]})}),"\n",(0,s.jsxs)(n.h3,{id:"is_base_of-and-is_same",children:[(0,s.jsx)(n.code,{children:"is_base_of"})," and ",(0,s.jsx)(n.code,{children:"is_same"})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"std::is_base_of"})," and ",(0,s.jsx)(n.code,{children:"std::is_same"})," type traits are used to check relationships between types."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::is_base_of<Base, Derived>::value"})," is ",(0,s.jsx)(n.code,{children:"true"})," if ",(0,s.jsx)(n.code,{children:"Derived"})," is derived from ",(0,s.jsx)(n.code,{children:"Base"}),", directly or indirectly."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"std::is_same<T1, T2>::value"})," is ",(0,s.jsx)(n.code,{children:"true"})," if ",(0,s.jsx)(n.code,{children:"T1"})," and ",(0,s.jsx)(n.code,{children:"T2"})," are the same type."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include <iostream>\n#include <type_traits>\n\nclass Base {};\nclass Derived : public Base {};\n\nint main() {\n    std::cout << "Is Derived derived from Base? " << std::is_base_of<Base, Derived>::value << std::endl;\n    std::cout << "Are int and double the same type? " << std::is_same<int, double>::value << std::endl;\n    \n    return 0;\n}\n'})}),"\n",(0,s.jsxs)(n.h3,{id:"future-and-promise",children:[(0,s.jsx)(n.code,{children:"future"})," and ",(0,s.jsx)(n.code,{children:"promise"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"// C++ Program to illustrate the use of std::future \n#include <chrono> \n#include <future> \n#include <iostream> \nusing namespace std; \n  \n// A simple function that returns some integer value \nvoid foo(promise<int> p) { p.set_value(25); } \n  \n// driver code \nint main() \n{ \n    // creating a future object and a thread that executes \n    // the function return two asynchronously \n  \n    promise<int> p; \n    future<int> f = p.get_future(); \n    ; \n  \n    // moving the task \n    thread t(foo, move(p)); \n  \n    t.join(); \n    cout << f.get(); // you can call it only once\n    cout << f.get(); //   what():  std::future_error: No associated state\n    \n    return 0; \n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"forward",children:(0,s.jsx)(n.code,{children:"forward"})}),"\n",(0,s.jsx)(n.p,{children:"TBD"})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>r});var s=t(6540);const i={},o=s.createContext(i);function d(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);