"use strict";(self.webpackChunkcpp_learn=self.webpackChunkcpp_learn||[]).push([[93],{1941:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>o});var a=t(4848),s=t(8453);const i={},r="RLvalues",l={id:"rl-values",title:"RLvalues",description:"Rvalues are temporary values that do not persist beyond the expression that uses them. Lvalues are values that persist beyond the expression that uses them.",source:"@site/docs/20-rl-values.md",sourceDirName:".",slug:"/rl-values",permalink:"/learn-cpp/docs/rl-values",draft:!1,unlisted:!1,editUrl:"https://github.com/michalskibinski109/learn-cpp/tree/main/docs/20-rl-values.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Copying and Moving",permalink:"/learn-cpp/docs/copying"},next:{title:"Classes and structures",permalink:"/learn-cpp/docs/classes_and_structs"}},c={},o=[{value:"Writing functions that accept rvalues",id:"writing-functions-that-accept-rvalues",level:3},{value:"<code>std::move</code>",id:"stdmove",level:3}];function d(e){const n={admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"rlvalues",children:"RLvalues"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"int getVal() { return 5; }\nint main()\n{\n    int i = 5; // i is an lvalue, 5 is an rvalue\n    int a = getVal(); // getVal() is an rvalue\n    getVal() = 4; // Error: getVal() is an rvalue\n}\n"})}),"\n",(0,a.jsxs)(n.blockquote,{children:["\n",(0,a.jsx)(n.p,{children:"Rvalues are temporary values that do not persist beyond the expression that uses them. Lvalues are values that persist beyond the expression that uses them."}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"int& getVal() { // this can be both lvalue and rvalue\n     static int value = 5;\n     return value;\n      }\nint main()\n{\n    int i = 5; // i is an lvalue, 5 is an rvalue\n    int a = getVal(); // getVal() is an rvalue\n    getVal() = 4; // getVal() is lvlaue \n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can't take lvalue reference from rvalue"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"void setVal(int& value) { }\n\n\nint main()\n{\n    int i = 5; // i is an lvalue, 5 is an rvalue\n    int& a = 4; // Error: 4 is an rvalue\n    setVal(4); // Error: 4 is an rvalue\n\n}\n"})}),"\n",(0,a.jsxs)(n.admonition,{title:"assigning rvalue to reference",type:"warning",children:[(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"const int& a = 4; // a is an lvalue reference\n"})}),(0,a.jsx)(n.p,{children:"What heppens under the hood:"}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"int temp = 4;\nconst int& a = temp;\n"})})]}),"\n",(0,a.jsx)(n.h3,{id:"writing-functions-that-accept-rvalues",children:"Writing functions that accept rvalues"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'void processValue(int& value) {\n    std::cout << "LValue processed: " << value << std::endl;\n}\n\nvoid processValue(int&& value) {\n    std::cout << "RValue processed: " << value << std::endl;\n}\n\nint main() {\n    int a = 5;\n    processValue(a); // LValue processed: 5\n    processValue(10); // RValue processed: 10\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"stdmove",children:(0,a.jsx)(n.code,{children:"std::move"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'class String\n{\npublic:\n    String(const char* string){\n        m_Size = strlen(string);\n        m_Data = new char[m_Size];\n        memcpy(m_Data, string, m_Size);\n    }\n    ~String(){\n        delete m_Data;\n    }\n    String(String& other) \n        : m_Size(other.m_Size), m_Data(other.m_Data)\n    {\n        std::cout << "Copied!" << std::endl;\n        memcpy(m_Data, other.m_Data, m_Size);\n    }\n   \n    void Print(){\n        for (uint32_t i = 0; i < m_Size; i++)\n            std::cout << m_Data[i];\n        std::cout << std::endl;\n    }\n};\n\nClass Entity\n{\npublic:\n    Entity(const String& name)\n        : m_Name(name) {}\n    void PrintName(){\n        std::cout << m_Name << std::endl;\n    }\nprivate:\n    String m_Name;\n};\n\n\nint main()\n{\n    Entity entity(String("miskibin")); // Copied!  \n    entity.PrintName();\n}\n\n'})}),"\n",(0,a.jsxs)(n.p,{children:["What heppens is that the ",(0,a.jsx)(n.code,{children:"String"})," object is copied to the ",(0,a.jsx)(n.code,{children:"Entity"})," object. We can avoid this by using ",(0,a.jsx)(n.code,{children:"std::move"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'Entity entity(std::move(String("miskibin"))); // Copied!  \n'})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var a=t(6540);const s={},i=a.createContext(s);function r(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);