"use strict";(self.webpackChunkcpp_learn=self.webpackChunkcpp_learn||[]).push([[958],{1351:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"category","label":"Basics","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"\ud83d\udee0\ufe0f Compilers Overview","href":"/learn-cpp/docs/compiler","docId":"compiler","unlisted":false},{"type":"link","label":"\ud83d\udd17 Linker","href":"/learn-cpp/docs/linker","docId":"linker","unlisted":false},{"type":"link","label":"\ud83d\udcc2 Header Files","href":"/learn-cpp/docs/headers","docId":"headers","unlisted":false},{"type":"link","label":"\ud83d\uddc3\ufe0f Variables","href":"/learn-cpp/docs/variables","docId":"variables","unlisted":false},{"type":"link","label":"\ud83d\udd27 Functions","href":"/learn-cpp/docs/functions","docId":"functions","unlisted":false},{"type":"link","label":"\ud83d\udd04 Ternary Operators","href":"/learn-cpp/docs/ternary_operators","docId":"ternary_operators","unlisted":false},{"type":"link","label":"\ud83d\udd12 Const Keyword","href":"/learn-cpp/docs/const","docId":"const","unlisted":false},{"type":"link","label":"\ud83d\uddc2\ufe0f Enums","href":"/learn-cpp/docs/enums","docId":"enums","unlisted":false},{"type":"link","label":"Raw pointers","href":"/learn-cpp/docs/pointers","docId":"pointers","unlisted":false},{"type":"link","label":"References in C++","href":"/learn-cpp/docs/references","docId":"references","unlisted":false},{"type":"link","label":"Strings and string literals","href":"/learn-cpp/docs/strings","docId":"strings","unlisted":false},{"type":"link","label":"Copying and Moving","href":"/learn-cpp/docs/copying","docId":"copying","unlisted":false},{"type":"link","label":"RLvalues","href":"/learn-cpp/docs/rl-values","docId":"rl-values","unlisted":false}]},{"type":"category","label":"OOP","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Classes and structures","href":"/learn-cpp/docs/classes_and_structs","docId":"classes_and_structs","unlisted":false},{"type":"link","label":"Operators","href":"/learn-cpp/docs/operators","docId":"operators","unlisted":false},{"type":"link","label":"Interfaces in C++","href":"/learn-cpp/docs/interfaces","docId":"interfaces","unlisted":false},{"type":"link","label":"Visibility in classes","href":"/learn-cpp/docs/visibility","docId":"visibility","unlisted":false},{"type":"link","label":"Implicit and Explicit Conversion","href":"/learn-cpp/docs/implicit_and_explicit","docId":"implicit_and_explicit","unlisted":false}]},{"type":"category","label":"STL","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Vectors and arrays","href":"/learn-cpp/docs/vectors","docId":"vectors","unlisted":false},{"type":"link","label":"Maps","href":"/learn-cpp/docs/maps","docId":"maps","unlisted":false},{"type":"link","label":"Memory","href":"/learn-cpp/docs/memory","docId":"memory","unlisted":false},{"type":"link","label":"STL functions","href":"/learn-cpp/docs/stl-operations","docId":"stl-operations","unlisted":false}]},{"type":"category","label":"Advanced Topics","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Lambdas","href":"/learn-cpp/docs/lambdas","docId":"lambdas","unlisted":false}]}]},"docs":{"classes_and_structs":{"id":"classes_and_structs","title":"Classes and structures","description":"Definition","sidebar":"tutorialSidebar"},"compiler":{"id":"compiler","title":"\ud83d\udee0\ufe0f Compilers Overview","description":"A compiler translates source code into machine code. The process involves several stages:","sidebar":"tutorialSidebar"},"const":{"id":"const","title":"\ud83d\udd12 Const Keyword","description":"\ud83d\udd22 Variables","sidebar":"tutorialSidebar"},"copying":{"id":"copying","title":"Copying and Moving","description":"When you are writing = you are always copying the value.","sidebar":"tutorialSidebar"},"enums":{"id":"enums","title":"\ud83d\uddc2\ufe0f Enums","description":"Enums, short for enumerations, are a way of defining a type in C++ that consists of named constants. Enums are used when we know all possible values a variable can have, and we want to restrict it to those values to avoid errors and make the code more readable.","sidebar":"tutorialSidebar"},"functions":{"id":"functions","title":"\ud83d\udd27 Functions","description":"\ud83d\udce6 Passing Class Objects to Functions","sidebar":"tutorialSidebar"},"headers":{"id":"headers","title":"\ud83d\udcc2 Header Files","description":"If you try to run a function from another file, the compiler does not know that it exists. That\'s why we create only the declaration of the function in the file where we want to use it.","sidebar":"tutorialSidebar"},"implicit_and_explicit":{"id":"implicit_and_explicit","title":"Implicit and Explicit Conversion","description":"Implicit Conversion","sidebar":"tutorialSidebar"},"interfaces":{"id":"interfaces","title":"Interfaces in C++","description":"In C++, interfaces are implemented using abstract classes, defined by having at least one pure virtual function. These classes cannot be instantiated directly and must be extended by other classes. Interfaces enforce that all derived classes implement specific behaviors.","sidebar":"tutorialSidebar"},"lambdas":{"id":"lambdas","title":"Lambdas","description":"Just like in python, you can define lambdas in C++.","sidebar":"tutorialSidebar"},"linker":{"id":"linker","title":"\ud83d\udd17 Linker","description":"A linker is a program that takes one or more object (.obj) files generated by a compiler and combines them into a single executable program.","sidebar":"tutorialSidebar"},"maps":{"id":"maps","title":"Maps","description":"Maps in C++ are associative containers that store elements formed by a combination of a key value and a mapped value. The key value is used to uniquely identify the element, and the mapped value is the content associated with the key. Maps are a part of the Standard Template Library (STL) and are very useful for efficiently searching, inserting, and deleting elements based on keys.","sidebar":"tutorialSidebar"},"memory":{"id":"memory","title":"Memory","description":"Heap","sidebar":"tutorialSidebar"},"operators":{"id":"operators","title":"Operators","description":"=, new, delete, ==, +=, etc.","sidebar":"tutorialSidebar"},"pointers":{"id":"pointers","title":"Raw pointers","description":"Pointer is just memory address of a variable.","sidebar":"tutorialSidebar"},"references":{"id":"references","title":"References in C++","description":"What is a reference?","sidebar":"tutorialSidebar"},"rl-values":{"id":"rl-values","title":"RLvalues","description":"Rvalues are temporary values that do not persist beyond the expression that uses them. Lvalues are values that persist beyond the expression that uses them.","sidebar":"tutorialSidebar"},"stl-operations":{"id":"stl-operations","title":"STL functions","description":"enableif and enableif_t","sidebar":"tutorialSidebar"},"strings":{"id":"strings","title":"Strings and string literals","description":"Char","sidebar":"tutorialSidebar"},"ternary_operators":{"id":"ternary_operators","title":"\ud83d\udd04 Ternary Operators","description":"\u270f\ufe0f Syntax","sidebar":"tutorialSidebar"},"variables":{"id":"variables","title":"\ud83d\uddc3\ufe0f Variables","description":"- \ud83d\udcdd Declaration: A variable declaration provides assurance to the compiler that there exists a variable with the given type and name so that the compiler can proceed for further compilation without requiring the complete detail about the variable. A variable declaration has its meaning at the time of compilation only; the compiler needs the actual variable definition at the time of linking the program.","sidebar":"tutorialSidebar"},"vectors":{"id":"vectors","title":"Vectors and arrays","description":"A vector is a dynamic array that can grow or shrink in size. It is a sequence container that encapsulates dynamic size arrays. It is very similar to the std::array container, but it is resizable. Vectors are very efficient in terms of time complexity. They have constant time complexity for both insertion and deletion at the end of the vector. However, insertion and deletion at the beginning or in the middle of the vector have linear time complexity.","sidebar":"tutorialSidebar"},"visibility":{"id":"visibility","title":"Visibility in classes","description":"In C++, classes have three types of visibility: public, protected, and private. These keywords determine how class members are accessible from outside the class.","sidebar":"tutorialSidebar"}}}}')}}]);